"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./hooks/useAuth.ts":
/*!**************************!*\
  !*** ./hooks/useAuth.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var _utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/usernameGenerator */ \"(app-pages-browser)/./utils/usernameGenerator.ts\");\n/* harmony import */ var _utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/profilePictureSelector */ \"(app-pages-browser)/./utils/profilePictureSelector.ts\");\n/* __next_internal_client_entry_do_not_use__ useAuth auto */ \n\n\n\nconst useAuth = ()=>{\n    const [session, setSession] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isAdmin, setIsAdmin] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [username, setUsername] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [profilePicture, setProfilePicture] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAuth.useEffect\": ()=>{\n            const initializeAuth = {\n                \"useAuth.useEffect.initializeAuth\": async ()=>{\n                    setLoading(true);\n                    const { session: currentSession, error } = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.getSession)();\n                    if (error) {\n                        console.error(\"Error getting session:\", error);\n                        setError(error.message);\n                    } else {\n                        var _currentSession_user_email;\n                        setSession(currentSession);\n                        // Check if user is admin by looking at their email\n                        if (currentSession === null || currentSession === void 0 ? void 0 : (_currentSession_user_email = currentSession.user.email) === null || _currentSession_user_email === void 0 ? void 0 : _currentSession_user_email.endsWith(\"@admin.com\")) {\n                            setIsAdmin(true);\n                        } else if (currentSession) {\n                            // For regular users, try to get existing username or generate a new one\n                            const savedUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.getSavedUsername)();\n                            if (savedUsername) {\n                                setUsername(savedUsername);\n                            } else {\n                                const newUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.generateRandomUsername)();\n                                (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.saveUsername)(newUsername);\n                                setUsername(newUsername);\n                            }\n                            // Get existing profile picture or fetch a new one\n                            const savedProfilePicture = (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.getSavedProfilePicture)();\n                            if (savedProfilePicture) {\n                                setProfilePicture(savedProfilePicture);\n                            } else {\n                                try {\n                                    const newProfilePicture = await (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.fetchRandomProfilePicture)();\n                                    (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.saveProfilePicture)(newProfilePicture);\n                                    setProfilePicture(newProfilePicture);\n                                } catch (error) {\n                                    console.error(\"Error fetching profile picture:\", error);\n                                    setProfilePicture(\"/profiles/default_profile.jpeg\");\n                                }\n                            }\n                        }\n                    }\n                    setLoading(false);\n                }\n            }[\"useAuth.useEffect.initializeAuth\"];\n            initializeAuth();\n            // Set up auth state listener\n            const { data: authListener } = _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.auth.onAuthStateChange({\n                \"useAuth.useEffect\": async (event, session)=>{\n                    var _session_user_email;\n                    setSession(session);\n                    if (session === null || session === void 0 ? void 0 : (_session_user_email = session.user.email) === null || _session_user_email === void 0 ? void 0 : _session_user_email.endsWith(\"@admin.com\")) {\n                        setIsAdmin(true);\n                    } else {\n                        setIsAdmin(false);\n                        // If user just signed in, check for username/profile or generate new ones\n                        if (event === \"SIGNED_IN\") {\n                            const savedUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.getSavedUsername)();\n                            if (savedUsername) {\n                                setUsername(savedUsername);\n                            } else {\n                                const newUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.generateRandomUsername)();\n                                (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.saveUsername)(newUsername);\n                                setUsername(newUsername);\n                            }\n                            const savedProfilePicture = (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.getSavedProfilePicture)();\n                            if (savedProfilePicture) {\n                                setProfilePicture(savedProfilePicture);\n                            } else {\n                                try {\n                                    const newProfilePicture = await (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.fetchRandomProfilePicture)();\n                                    (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.saveProfilePicture)(newProfilePicture);\n                                    setProfilePicture(newProfilePicture);\n                                } catch (error) {\n                                    console.error(\"Error fetching profile picture:\", error);\n                                    setProfilePicture(\"/profiles/default_profile.jpeg\");\n                                }\n                            }\n                        } else if (event === \"SIGNED_OUT\") {\n                            setUsername(null);\n                            setProfilePicture(null);\n                        }\n                    }\n                }\n            }[\"useAuth.useEffect\"]);\n            return ({\n                \"useAuth.useEffect\": ()=>{\n                    if (authListener && authListener.subscription) {\n                        authListener.subscription.unsubscribe();\n                    }\n                }\n            })[\"useAuth.useEffect\"];\n        }\n    }[\"useAuth.useEffect\"], []);\n    const handleSignInAnonymously = async ()=>{\n        setLoading(true);\n        setError(null);\n        const { data, error } = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.signInAnonymously)();\n        if (error) {\n            setError(error.message);\n        } else {\n            setSession(data.session);\n            // Generate and save a random username for the new anonymous user\n            const newUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.generateRandomUsername)();\n            (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.saveUsername)(newUsername);\n            setUsername(newUsername);\n            // Generate and save a random profile picture\n            try {\n                const newProfilePicture = await (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.fetchRandomProfilePicture)();\n                (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.saveProfilePicture)(newProfilePicture);\n                setProfilePicture(newProfilePicture);\n            } catch (error) {\n                console.error(\"Error fetching profile picture:\", error);\n                setProfilePicture(\"/profiles/default_profile.jpeg\");\n            }\n        }\n        setLoading(false);\n        return {\n            data,\n            error\n        };\n    };\n    // Function to refresh the current username\n    const handleRefreshUsername = ()=>{\n        if (session && !isAdmin) {\n            const newUsername = (0,_utils_usernameGenerator__WEBPACK_IMPORTED_MODULE_2__.refreshUsername)();\n            setUsername(newUsername);\n            return newUsername;\n        }\n        return null;\n    };\n    // Function to refresh the current profile picture\n    const handleRefreshProfilePicture = async ()=>{\n        if (session && !isAdmin) {\n            try {\n                const newProfilePicture = await (0,_utils_profilePictureSelector__WEBPACK_IMPORTED_MODULE_3__.refreshProfilePicture)();\n                setProfilePicture(newProfilePicture);\n                return newProfilePicture;\n            } catch (error) {\n                console.error(\"Error refreshing profile picture:\", error);\n                return null;\n            }\n        }\n        return null;\n    };\n    const handleSignOut = async ()=>{\n        setLoading(true);\n        setError(null);\n        const { error } = await (0,_lib_supabase__WEBPACK_IMPORTED_MODULE_1__.signOut)();\n        if (error) {\n            setError(error.message);\n        } else {\n            setSession(null);\n            setIsAdmin(false);\n            setUsername(null);\n            setProfilePicture(null);\n            // Clear the username and profile picture from local storage on sign out\n            if (true) {\n                localStorage.removeItem(\"randomUsername\");\n                localStorage.removeItem(\"profilePicture\");\n            }\n        }\n        setLoading(false);\n        return {\n            error\n        };\n    };\n    return {\n        session,\n        user: (session === null || session === void 0 ? void 0 : session.user) || null,\n        isAdmin,\n        loading,\n        error,\n        username,\n        profilePicture,\n        signInAnonymously: handleSignInAnonymously,\n        signInWithEmail: handleSignInWithEmail,\n        signOut: handleSignOut,\n        refreshUsername: handleRefreshUsername,\n        refreshProfilePicture: handleRefreshProfilePicture\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1ZLDhCQUE4QjtRQUNsQyxJQUFJaEMsV0FBVyxDQUFDTSxTQUFTO1lBQ3ZCLElBQUk7Z0JBQ0YsTUFBTWdCLG9CQUFvQixNQUFNeEIsb0ZBQXFCQTtnQkFDckRhLGtCQUFrQlc7Z0JBQ2xCLE9BQU9BO1lBQ1QsRUFBRSxPQUFPbEIsT0FBTztnQkFDZFUsUUFBUVYsS0FBSyxDQUFDLHFDQUFxQ0E7Z0JBQ25ELE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRUEsTUFBTTZCLGdCQUFnQjtRQUNwQjlCLFdBQVc7UUFDWEUsU0FBUztRQUVULE1BQU0sRUFBRUQsS0FBSyxFQUFFLEdBQUcsTUFBTWhCLHNEQUFPQTtRQUUvQixJQUFJZ0IsT0FBTztZQUNUQyxTQUFTRCxNQUFNVyxPQUFPO1FBQ3hCLE9BQU87WUFDTGQsV0FBVztZQUNYTSxXQUFXO1lBQ1hFLFlBQVk7WUFDWkUsa0JBQWtCO1lBQ2xCLHdFQUF3RTtZQUN4RSxJQUFJLElBQTZCLEVBQUU7Z0JBQ2pDdUIsYUFBYUMsVUFBVSxDQUFDO2dCQUN4QkQsYUFBYUMsVUFBVSxDQUFDO1lBQzFCO1FBQ0Y7UUFFQWhDLFdBQVc7UUFDWCxPQUFPO1lBQUVDO1FBQU07SUFDakI7SUFFQSxPQUFPO1FBQ0xKO1FBQ0FnQixNQUFNaEIsQ0FBQUEsb0JBQUFBLDhCQUFBQSxRQUFTZ0IsSUFBSSxLQUFJO1FBQ3ZCVjtRQUNBSjtRQUNBRTtRQUNBSTtRQUNBRTtRQUNBdkIsbUJBQW1CMkM7UUFDbkJNLGlCQUFpQkM7UUFDakJqRCxTQUFTNkM7UUFDVHhDLGlCQUFpQnNDO1FBQ2pCakMsdUJBQXVCa0M7SUFDekI7QUFDRixFQUFFIiwic291cmNlcyI6WyIvaG9tZS90ci1nZ3IvTmVyZFByb2plY3RzL25leHRqcy9haS1tb2RlcmF0aW9uL2hvb2tzL3VzZUF1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIHN1cGFiYXNlLFxuICBzaWduSW5Bbm9ueW1vdXNseSxcbiAgc2lnbkluV2l0aEVtYWlsLFxuICBzaWduT3V0LFxuICBnZXRTZXNzaW9uLFxufSBmcm9tIFwiQC9saWIvc3VwYWJhc2VcIjtcbmltcG9ydCB7IFNlc3Npb24gfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XG5pbXBvcnQge1xuICBnZW5lcmF0ZVJhbmRvbVVzZXJuYW1lLFxuICBnZXRTYXZlZFVzZXJuYW1lLFxuICBzYXZlVXNlcm5hbWUsXG4gIHJlZnJlc2hVc2VybmFtZSBhcyByZWZyZXNoUmFuZG9tVXNlcm5hbWUsXG59IGZyb20gXCJAL3V0aWxzL3VzZXJuYW1lR2VuZXJhdG9yXCI7XG5pbXBvcnQge1xuICBnZXRTYXZlZFByb2ZpbGVQaWN0dXJlLFxuICBzYXZlUHJvZmlsZVBpY3R1cmUsXG4gIGZldGNoUmFuZG9tUHJvZmlsZVBpY3R1cmUsXG4gIHJlZnJlc2hQcm9maWxlUGljdHVyZSxcbn0gZnJvbSBcIkAvdXRpbHMvcHJvZmlsZVBpY3R1cmVTZWxlY3RvclwiO1xuXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHtcbiAgY29uc3QgW3Nlc3Npb24sIHNldFNlc3Npb25dID0gdXNlU3RhdGU8U2Vzc2lvbiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzQWRtaW4sIHNldElzQWRtaW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdXNlcm5hbWUsIHNldFVzZXJuYW1lXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcHJvZmlsZVBpY3R1cmUsIHNldFByb2ZpbGVQaWN0dXJlXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZUF1dGggPSBhc3luYyAoKSA9PiB7XG4gICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgY29uc3QgeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IGdldFNlc3Npb24oKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBnZXR0aW5nIHNlc3Npb246XCIsIGVycm9yKTtcbiAgICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIGFkbWluIGJ5IGxvb2tpbmcgYXQgdGhlaXIgZW1haWxcbiAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uPy51c2VyLmVtYWlsPy5lbmRzV2l0aChcIkBhZG1pbi5jb21cIikpIHtcbiAgICAgICAgICBzZXRJc0FkbWluKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgLy8gRm9yIHJlZ3VsYXIgdXNlcnMsIHRyeSB0byBnZXQgZXhpc3RpbmcgdXNlcm5hbWUgb3IgZ2VuZXJhdGUgYSBuZXcgb25lXG4gICAgICAgICAgY29uc3Qgc2F2ZWRVc2VybmFtZSA9IGdldFNhdmVkVXNlcm5hbWUoKTtcbiAgICAgICAgICBpZiAoc2F2ZWRVc2VybmFtZSkge1xuICAgICAgICAgICAgc2V0VXNlcm5hbWUoc2F2ZWRVc2VybmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1VzZXJuYW1lID0gZ2VuZXJhdGVSYW5kb21Vc2VybmFtZSgpO1xuICAgICAgICAgICAgc2F2ZVVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICAgICAgICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZXQgZXhpc3RpbmcgcHJvZmlsZSBwaWN0dXJlIG9yIGZldGNoIGEgbmV3IG9uZVxuICAgICAgICAgIGNvbnN0IHNhdmVkUHJvZmlsZVBpY3R1cmUgPSBnZXRTYXZlZFByb2ZpbGVQaWN0dXJlKCk7XG4gICAgICAgICAgaWYgKHNhdmVkUHJvZmlsZVBpY3R1cmUpIHtcbiAgICAgICAgICAgIHNldFByb2ZpbGVQaWN0dXJlKHNhdmVkUHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdQcm9maWxlUGljdHVyZSA9IGF3YWl0IGZldGNoUmFuZG9tUHJvZmlsZVBpY3R1cmUoKTtcbiAgICAgICAgICAgICAgc2F2ZVByb2ZpbGVQaWN0dXJlKG5ld1Byb2ZpbGVQaWN0dXJlKTtcbiAgICAgICAgICAgICAgc2V0UHJvZmlsZVBpY3R1cmUobmV3UHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHByb2ZpbGUgcGljdHVyZTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICBzZXRQcm9maWxlUGljdHVyZShcIi9wcm9maWxlcy9kZWZhdWx0X3Byb2ZpbGUuanBlZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfTtcblxuICAgIGluaXRpYWxpemVBdXRoKCk7XG5cbiAgICAvLyBTZXQgdXAgYXV0aCBzdGF0ZSBsaXN0ZW5lclxuICAgIGNvbnN0IHsgZGF0YTogYXV0aExpc3RlbmVyIH0gPSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKFxuICAgICAgYXN5bmMgKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgIHNldFNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICAgICAgaWYgKHNlc3Npb24/LnVzZXIuZW1haWw/LmVuZHNXaXRoKFwiQGFkbWluLmNvbVwiKSkge1xuICAgICAgICAgIHNldElzQWRtaW4odHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0SXNBZG1pbihmYWxzZSk7XG5cbiAgICAgICAgICAvLyBJZiB1c2VyIGp1c3Qgc2lnbmVkIGluLCBjaGVjayBmb3IgdXNlcm5hbWUvcHJvZmlsZSBvciBnZW5lcmF0ZSBuZXcgb25lc1xuICAgICAgICAgIGlmIChldmVudCA9PT0gXCJTSUdORURfSU5cIikge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWRVc2VybmFtZSA9IGdldFNhdmVkVXNlcm5hbWUoKTtcbiAgICAgICAgICAgIGlmIChzYXZlZFVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgIHNldFVzZXJuYW1lKHNhdmVkVXNlcm5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3VXNlcm5hbWUgPSBnZW5lcmF0ZVJhbmRvbVVzZXJuYW1lKCk7XG4gICAgICAgICAgICAgIHNhdmVVc2VybmFtZShuZXdVc2VybmFtZSk7XG4gICAgICAgICAgICAgIHNldFVzZXJuYW1lKG5ld1VzZXJuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2F2ZWRQcm9maWxlUGljdHVyZSA9IGdldFNhdmVkUHJvZmlsZVBpY3R1cmUoKTtcbiAgICAgICAgICAgIGlmIChzYXZlZFByb2ZpbGVQaWN0dXJlKSB7XG4gICAgICAgICAgICAgIHNldFByb2ZpbGVQaWN0dXJlKHNhdmVkUHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQcm9maWxlUGljdHVyZSA9IGF3YWl0IGZldGNoUmFuZG9tUHJvZmlsZVBpY3R1cmUoKTtcbiAgICAgICAgICAgICAgICBzYXZlUHJvZmlsZVBpY3R1cmUobmV3UHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICAgICAgICAgIHNldFByb2ZpbGVQaWN0dXJlKG5ld1Byb2ZpbGVQaWN0dXJlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcHJvZmlsZSBwaWN0dXJlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgc2V0UHJvZmlsZVBpY3R1cmUoXCIvcHJvZmlsZXMvZGVmYXVsdF9wcm9maWxlLmpwZWdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSBcIlNJR05FRF9PVVRcIikge1xuICAgICAgICAgICAgc2V0VXNlcm5hbWUobnVsbCk7XG4gICAgICAgICAgICBzZXRQcm9maWxlUGljdHVyZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChhdXRoTGlzdGVuZXIgJiYgYXV0aExpc3RlbmVyLnN1YnNjcmlwdGlvbikge1xuICAgICAgICBhdXRoTGlzdGVuZXIuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25JbkFub255bW91c2x5ID0gYXN5bmMgKCkgPT4ge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzaWduSW5Bbm9ueW1vdXNseSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhbmQgc2F2ZSBhIHJhbmRvbSB1c2VybmFtZSBmb3IgdGhlIG5ldyBhbm9ueW1vdXMgdXNlclxuICAgICAgY29uc3QgbmV3VXNlcm5hbWUgPSBnZW5lcmF0ZVJhbmRvbVVzZXJuYW1lKCk7XG4gICAgICBzYXZlVXNlcm5hbWUobmV3VXNlcm5hbWUpO1xuICAgICAgc2V0VXNlcm5hbWUobmV3VXNlcm5hbWUpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhbmQgc2F2ZSBhIHJhbmRvbSBwcm9maWxlIHBpY3R1cmVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld1Byb2ZpbGVQaWN0dXJlID0gYXdhaXQgZmV0Y2hSYW5kb21Qcm9maWxlUGljdHVyZSgpO1xuICAgICAgICBzYXZlUHJvZmlsZVBpY3R1cmUobmV3UHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICBzZXRQcm9maWxlUGljdHVyZShuZXdQcm9maWxlUGljdHVyZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcHJvZmlsZSBwaWN0dXJlOlwiLCBlcnJvcik7XG4gICAgICAgIHNldFByb2ZpbGVQaWN0dXJlKFwiL3Byb2ZpbGVzL2RlZmF1bHRfcHJvZmlsZS5qcGVnXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gcmVmcmVzaCB0aGUgY3VycmVudCB1c2VybmFtZVxuICBjb25zdCBoYW5kbGVSZWZyZXNoVXNlcm5hbWUgPSAoKSA9PiB7XG4gICAgaWYgKHNlc3Npb24gJiYgIWlzQWRtaW4pIHtcbiAgICAgIGNvbnN0IG5ld1VzZXJuYW1lID0gcmVmcmVzaFJhbmRvbVVzZXJuYW1lKCk7XG4gICAgICBzZXRVc2VybmFtZShuZXdVc2VybmFtZSk7XG4gICAgICByZXR1cm4gbmV3VXNlcm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHJlZnJlc2ggdGhlIGN1cnJlbnQgcHJvZmlsZSBwaWN0dXJlXG4gIGNvbnN0IGhhbmRsZVJlZnJlc2hQcm9maWxlUGljdHVyZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoc2Vzc2lvbiAmJiAhaXNBZG1pbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3UHJvZmlsZVBpY3R1cmUgPSBhd2FpdCByZWZyZXNoUHJvZmlsZVBpY3R1cmUoKTtcbiAgICAgICAgc2V0UHJvZmlsZVBpY3R1cmUobmV3UHJvZmlsZVBpY3R1cmUpO1xuICAgICAgICByZXR1cm4gbmV3UHJvZmlsZVBpY3R1cmU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVmcmVzaGluZyBwcm9maWxlIHBpY3R1cmU6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25PdXQgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHNpZ25PdXQoKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlc3Npb24obnVsbCk7XG4gICAgICBzZXRJc0FkbWluKGZhbHNlKTtcbiAgICAgIHNldFVzZXJuYW1lKG51bGwpO1xuICAgICAgc2V0UHJvZmlsZVBpY3R1cmUobnVsbCk7XG4gICAgICAvLyBDbGVhciB0aGUgdXNlcm5hbWUgYW5kIHByb2ZpbGUgcGljdHVyZSBmcm9tIGxvY2FsIHN0b3JhZ2Ugb24gc2lnbiBvdXRcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwicmFuZG9tVXNlcm5hbWVcIik7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwicHJvZmlsZVBpY3R1cmVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNlc3Npb24sXG4gICAgdXNlcjogc2Vzc2lvbj8udXNlciB8fCBudWxsLFxuICAgIGlzQWRtaW4sXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICB1c2VybmFtZSxcbiAgICBwcm9maWxlUGljdHVyZSxcbiAgICBzaWduSW5Bbm9ueW1vdXNseTogaGFuZGxlU2lnbkluQW5vbnltb3VzbHksXG4gICAgc2lnbkluV2l0aEVtYWlsOiBoYW5kbGVTaWduSW5XaXRoRW1haWwsXG4gICAgc2lnbk91dDogaGFuZGxlU2lnbk91dCxcbiAgICByZWZyZXNoVXNlcm5hbWU6IGhhbmRsZVJlZnJlc2hVc2VybmFtZSxcbiAgICByZWZyZXNoUHJvZmlsZVBpY3R1cmU6IGhhbmRsZVJlZnJlc2hQcm9maWxlUGljdHVyZSxcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJzdXBhYmFzZSIsInNpZ25JbkFub255bW91c2x5Iiwic2lnbk91dCIsImdldFNlc3Npb24iLCJnZW5lcmF0ZVJhbmRvbVVzZXJuYW1lIiwiZ2V0U2F2ZWRVc2VybmFtZSIsInNhdmVVc2VybmFtZSIsInJlZnJlc2hVc2VybmFtZSIsInJlZnJlc2hSYW5kb21Vc2VybmFtZSIsImdldFNhdmVkUHJvZmlsZVBpY3R1cmUiLCJzYXZlUHJvZmlsZVBpY3R1cmUiLCJmZXRjaFJhbmRvbVByb2ZpbGVQaWN0dXJlIiwicmVmcmVzaFByb2ZpbGVQaWN0dXJlIiwidXNlQXV0aCIsInNlc3Npb24iLCJzZXRTZXNzaW9uIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiaXNBZG1pbiIsInNldElzQWRtaW4iLCJ1c2VybmFtZSIsInNldFVzZXJuYW1lIiwicHJvZmlsZVBpY3R1cmUiLCJzZXRQcm9maWxlUGljdHVyZSIsImluaXRpYWxpemVBdXRoIiwiY3VycmVudFNlc3Npb24iLCJjb25zb2xlIiwibWVzc2FnZSIsInVzZXIiLCJlbWFpbCIsImVuZHNXaXRoIiwic2F2ZWRVc2VybmFtZSIsIm5ld1VzZXJuYW1lIiwic2F2ZWRQcm9maWxlUGljdHVyZSIsIm5ld1Byb2ZpbGVQaWN0dXJlIiwiZGF0YSIsImF1dGhMaXN0ZW5lciIsImF1dGgiLCJvbkF1dGhTdGF0ZUNoYW5nZSIsImV2ZW50Iiwic3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJoYW5kbGVTaWduSW5Bbm9ueW1vdXNseSIsImhhbmRsZVJlZnJlc2hVc2VybmFtZSIsImhhbmRsZVJlZnJlc2hQcm9maWxlUGljdHVyZSIsImhhbmRsZVNpZ25PdXQiLCJsb2NhbFN0b3JhZ2UiLCJyZW1vdmVJdGVtIiwic2lnbkluV2l0aEVtYWlsIiwiaGFuZGxlU2lnbkluV2l0aEVtYWlsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useAuth.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/profilePictureSelector.ts":
/*!*****************************************!*\
  !*** ./utils/profilePictureSelector.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PROFILE_PICTURES: () => (/* binding */ PROFILE_PICTURES),\n/* harmony export */   fetchRandomProfilePicture: () => (/* binding */ fetchRandomProfilePicture),\n/* harmony export */   getAllProfilePictures: () => (/* binding */ getAllProfilePictures),\n/* harmony export */   getCurrentProfilePicture: () => (/* binding */ getCurrentProfilePicture),\n/* harmony export */   getRandomProfilePicture: () => (/* binding */ getRandomProfilePicture),\n/* harmony export */   getSavedProfilePicture: () => (/* binding */ getSavedProfilePicture),\n/* harmony export */   refreshProfilePicture: () => (/* binding */ refreshProfilePicture),\n/* harmony export */   saveProfilePicture: () => (/* binding */ saveProfilePicture)\n/* harmony export */ });\n// filepath: /home/tr-ggr/NerdProjects/nextjs/ai-moderation/utils/profilePictureSelector.ts\n// Utility function to get a random profile picture path\n// Enum of all available profile picture filenames\nconst PROFILE_PICTURES = [\n    \"AdrianTSajulga_profile.jpeg\",\n    \"AlecGiuseppeKSo_profile.jpeg\",\n    \"AlessandraBeatrizAKisteria_profile.jpeg\",\n    \"AntonioMUbaldo_profile.jpeg\",\n    \"ArdelTiocoJeffLLauron_profile.jpeg\",\n    \"AvrilNigelMChua_profile.jpeg\",\n    \"BasilXavierBMendoza_profile.jpeg\",\n    \"ChrisJordanGAliac_profile.jpeg\",\n    \"ChristianGeloDCadavos_profile.jpeg\",\n    \"DechieASullano_profile.jpeg\",\n    \"DerrickCBinangbang_profile.jpeg\",\n    \"EllydhoreGabrylleSBelleza_profile.jpeg\",\n    \"ErinAsia_profile.jpeg\",\n    \"FelicityVOrate_profile.jpeg\",\n    \"FelisaMelanieFayGBascug_profile.jpeg\",\n    \"FielLouisLOmas-as_profile.jpeg\",\n    \"FrancisWedemeyerNDayagro_profile.jpeg\",\n    \"JetherVOmictin_profile.jpeg\",\n    \"JianLevCOlamit_profile.jpeg\",\n    \"JorashJonathanCRobillos_profile.jpeg\",\n    \"JuliaLaineGSegundo_profile.jpeg\",\n    \"KarlChristianPAjero_profile.jpeg\",\n    \"KayeAizernerEvangelista_profile.jpeg\",\n    \"KeiruVentCabili_profile.jpeg\",\n    \"KevinJoshRAtay_profile.jpeg\",\n    \"KyleAngelaMar_profile.jpeg\",\n    \"MaltJohnVianneyCSolon_profile.jpeg\",\n    \"MarkAdrianBBaring_profile.jpeg\",\n    \"MarsLBenitez_profile.jpeg\",\n    \"MaryKarylleGDelosReyes_profile.jpeg\",\n    \"MauriceRTañeca_profile.jpeg\",\n    \"MorielEdgarDeandreBien_profile.jpeg\",\n    \"RanzMatheuMLumayno_profile.jpeg\",\n    \"RoddneilBGemina_profile.jpeg\",\n    \"SimonLysterPEscaño_profile.jpeg\",\n    \"StephenClintDSales_profile.jpeg\",\n    \"TheodoreALadera_profile.jpeg\",\n    \"ThomasDanjoMManulat_profile.jpeg\",\n    \"TristanJameYTolentino_profile.jpeg\",\n    \"ValMykelCevenCBolante_profile.jpeg\"\n];\n/**\n * Gets a random profile picture filename from the profiles enum\n * @returns Path to a random profile picture relative to the public directory\n */ function getRandomProfilePicture() {\n    try {\n        // Select a random profile picture from the enum\n        const randomIndex = Math.floor(Math.random() * PROFILE_PICTURES.length);\n        const randomProfileFile = PROFILE_PICTURES[randomIndex];\n        // Return the path relative to the public directory\n        return \"/profiles/\".concat(randomProfileFile);\n    } catch (error) {\n        console.error(\"Error getting random profile picture:\", error);\n        // Return a default profile picture path if there's an error\n        return \"/profiles/default_profile.jpeg\";\n    }\n}\n/**\n * Server-side function to get all available profile pictures\n * @returns Array of paths to all profile pictures\n */ function getAllProfilePictures() {\n    return PROFILE_PICTURES.map((file)=>\"/profiles/\".concat(file));\n}\n/**\n * Client-side function to get saved profile picture from local storage\n * @returns The saved profile picture path or null if none is saved\n */ function getSavedProfilePicture() {\n    if (true) {\n        return localStorage.getItem(\"profilePicture\");\n    }\n    return null;\n}\n/**\n * Client-side function to save a profile picture path to local storage\n * @param profilePath The profile picture path to save\n */ function saveProfilePicture(profilePath) {\n    if (true) {\n        localStorage.setItem(\"profilePicture\", profilePath);\n    }\n}\n/**\n * Client-side function to get the current profile picture or generate a new one if none exists\n * @returns The current profile picture path\n */ function getCurrentProfilePicture() {\n    if (true) {\n        const savedProfilePicture = getSavedProfilePicture();\n        if (savedProfilePicture) {\n            return savedProfilePicture;\n        }\n    // Generate a new one on the client side\n    // We can't use fs on client side, so we'll need to handle this differently\n    }\n    return \"/profiles/default_profile.jpeg\";\n}\n/**\n * Client-side function to fetch a random profile picture from the API\n * @returns Promise that resolves to a random profile picture path\n */ async function fetchRandomProfilePicture() {\n    try {\n        const response = await fetch(\"/api/profile/random\");\n        const data = await response.json();\n        return data.profilePicture;\n    } catch (error) {\n        console.error(\"Error fetching random profile picture:\", error);\n        return \"/profiles/default_profile.jpeg\";\n    }\n}\n/**\n * Client-side function to refresh the profile picture with a new randomly generated one\n * @returns Promise that resolves to the new profile picture path\n */ async function refreshProfilePicture() {\n    const newProfilePicture = await fetchRandomProfilePicture();\n    saveProfilePicture(newProfilePicture);\n    return newProfilePicture;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3Byb2ZpbGVQaWN0dXJlU2VsZWN0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSwyRkFBMkY7QUFDM0Ysd0RBQXdEO0FBS3hELGtEQUFrRDtBQUMzQyxNQUFNQSxtQkFBbUI7SUFDOUI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRCxDQUFDO0FBRUY7OztDQUdDLEdBQ00sU0FBU0M7SUFDZCxJQUFJO1FBQ0YsZ0RBQWdEO1FBQ2hELE1BQU1DLGNBQWNDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLTCxpQkFBaUJNLE1BQU07UUFDdEUsTUFBTUMsb0JBQW9CUCxnQkFBZ0IsQ0FBQ0UsWUFBWTtRQUV2RCxtREFBbUQ7UUFDbkQsT0FBTyxhQUErQixPQUFsQks7SUFDdEIsRUFBRSxPQUFPQyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyx5Q0FBeUNBO1FBQ3ZELDREQUE0RDtRQUM1RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNFO0lBQ2QsT0FBT1YsaUJBQWlCVyxHQUFHLENBQUMsQ0FBQ0MsT0FBUyxhQUFrQixPQUFMQTtBQUNyRDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSSxJQUE2QixFQUFFO1FBQ2pDLE9BQU9DLGFBQWFDLE9BQU8sQ0FBQztJQUM5QjtJQUNBLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDLG1CQUFtQkMsV0FBbUI7SUFDcEQsSUFBSSxJQUE2QixFQUFFO1FBQ2pDSCxhQUFhSSxPQUFPLENBQUMsa0JBQWtCRDtJQUN6QztBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0U7SUFDZCxJQUFJLElBQTZCLEVBQUU7UUFDakMsTUFBTUMsc0JBQXNCUDtRQUM1QixJQUFJTyxxQkFBcUI7WUFDdkIsT0FBT0E7UUFDVDtJQUNBLHdDQUF3QztJQUN4QywyRUFBMkU7SUFDN0U7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDTSxlQUFlQztJQUNwQixJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNO1FBQzdCLE1BQU1DLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtRQUNoQyxPQUFPRCxLQUFLRSxjQUFjO0lBQzVCLEVBQUUsT0FBT2xCLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDBDQUEwQ0E7UUFDeEQsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxlQUFlbUI7SUFDcEIsTUFBTUMsb0JBQW9CLE1BQU1QO0lBQ2hDTCxtQkFBbUJZO0lBQ25CLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL3RyLWdnci9OZXJkUHJvamVjdHMvbmV4dGpzL2FpLW1vZGVyYXRpb24vdXRpbHMvcHJvZmlsZVBpY3R1cmVTZWxlY3Rvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmaWxlcGF0aDogL2hvbWUvdHItZ2dyL05lcmRQcm9qZWN0cy9uZXh0anMvYWktbW9kZXJhdGlvbi91dGlscy9wcm9maWxlUGljdHVyZVNlbGVjdG9yLnRzXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGdldCBhIHJhbmRvbSBwcm9maWxlIHBpY3R1cmUgcGF0aFxuXG5pbXBvcnQgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG4vLyBFbnVtIG9mIGFsbCBhdmFpbGFibGUgcHJvZmlsZSBwaWN0dXJlIGZpbGVuYW1lc1xuZXhwb3J0IGNvbnN0IFBST0ZJTEVfUElDVFVSRVMgPSBbXG4gIFwiQWRyaWFuVFNhanVsZ2FfcHJvZmlsZS5qcGVnXCIsXG4gIFwiQWxlY0dpdXNlcHBlS1NvX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkFsZXNzYW5kcmFCZWF0cml6QUtpc3RlcmlhX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkFudG9uaW9NVWJhbGRvX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkFyZGVsVGlvY29KZWZmTExhdXJvbl9wcm9maWxlLmpwZWdcIixcbiAgXCJBdnJpbE5pZ2VsTUNodWFfcHJvZmlsZS5qcGVnXCIsXG4gIFwiQmFzaWxYYXZpZXJCTWVuZG96YV9wcm9maWxlLmpwZWdcIixcbiAgXCJDaHJpc0pvcmRhbkdBbGlhY19wcm9maWxlLmpwZWdcIixcbiAgXCJDaHJpc3RpYW5HZWxvRENhZGF2b3NfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRGVjaGllQVN1bGxhbm9fcHJvZmlsZS5qcGVnXCIsXG4gIFwiRGVycmlja0NCaW5hbmdiYW5nX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkVsbHlkaG9yZUdhYnJ5bGxlU0JlbGxlemFfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRXJpbkFzaWFfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRmVsaWNpdHlWT3JhdGVfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRmVsaXNhTWVsYW5pZUZheUdCYXNjdWdfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRmllbExvdWlzTE9tYXMtYXNfcHJvZmlsZS5qcGVnXCIsXG4gIFwiRnJhbmNpc1dlZGVtZXllck5EYXlhZ3JvX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkpldGhlclZPbWljdGluX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkppYW5MZXZDT2xhbWl0X3Byb2ZpbGUuanBlZ1wiLFxuICBcIkpvcmFzaEpvbmF0aGFuQ1JvYmlsbG9zX3Byb2ZpbGUuanBlZ1wiLFxuICBcIkp1bGlhTGFpbmVHU2VndW5kb19wcm9maWxlLmpwZWdcIixcbiAgXCJLYXJsQ2hyaXN0aWFuUEFqZXJvX3Byb2ZpbGUuanBlZ1wiLFxuICBcIktheWVBaXplcm5lckV2YW5nZWxpc3RhX3Byb2ZpbGUuanBlZ1wiLFxuICBcIktlaXJ1VmVudENhYmlsaV9wcm9maWxlLmpwZWdcIixcbiAgXCJLZXZpbkpvc2hSQXRheV9wcm9maWxlLmpwZWdcIixcbiAgXCJLeWxlQW5nZWxhTWFyX3Byb2ZpbGUuanBlZ1wiLFxuICBcIk1hbHRKb2huVmlhbm5leUNTb2xvbl9wcm9maWxlLmpwZWdcIixcbiAgXCJNYXJrQWRyaWFuQkJhcmluZ19wcm9maWxlLmpwZWdcIixcbiAgXCJNYXJzTEJlbml0ZXpfcHJvZmlsZS5qcGVnXCIsXG4gIFwiTWFyeUthcnlsbGVHRGVsb3NSZXllc19wcm9maWxlLmpwZWdcIixcbiAgXCJNYXVyaWNlUlRhw7FlY2FfcHJvZmlsZS5qcGVnXCIsXG4gIFwiTW9yaWVsRWRnYXJEZWFuZHJlQmllbl9wcm9maWxlLmpwZWdcIixcbiAgXCJSYW56TWF0aGV1TUx1bWF5bm9fcHJvZmlsZS5qcGVnXCIsXG4gIFwiUm9kZG5laWxCR2VtaW5hX3Byb2ZpbGUuanBlZ1wiLFxuICBcIlNpbW9uTHlzdGVyUEVzY2HDsW9fcHJvZmlsZS5qcGVnXCIsXG4gIFwiU3RlcGhlbkNsaW50RFNhbGVzX3Byb2ZpbGUuanBlZ1wiLFxuICBcIlRoZW9kb3JlQUxhZGVyYV9wcm9maWxlLmpwZWdcIixcbiAgXCJUaG9tYXNEYW5qb01NYW51bGF0X3Byb2ZpbGUuanBlZ1wiLFxuICBcIlRyaXN0YW5KYW1lWVRvbGVudGlub19wcm9maWxlLmpwZWdcIixcbiAgXCJWYWxNeWtlbENldmVuQ0JvbGFudGVfcHJvZmlsZS5qcGVnXCIsXG5dO1xuXG4vKipcbiAqIEdldHMgYSByYW5kb20gcHJvZmlsZSBwaWN0dXJlIGZpbGVuYW1lIGZyb20gdGhlIHByb2ZpbGVzIGVudW1cbiAqIEByZXR1cm5zIFBhdGggdG8gYSByYW5kb20gcHJvZmlsZSBwaWN0dXJlIHJlbGF0aXZlIHRvIHRoZSBwdWJsaWMgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21Qcm9maWxlUGljdHVyZSgpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIC8vIFNlbGVjdCBhIHJhbmRvbSBwcm9maWxlIHBpY3R1cmUgZnJvbSB0aGUgZW51bVxuICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogUFJPRklMRV9QSUNUVVJFUy5sZW5ndGgpO1xuICAgIGNvbnN0IHJhbmRvbVByb2ZpbGVGaWxlID0gUFJPRklMRV9QSUNUVVJFU1tyYW5kb21JbmRleF07XG5cbiAgICAvLyBSZXR1cm4gdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIHB1YmxpYyBkaXJlY3RvcnlcbiAgICByZXR1cm4gYC9wcm9maWxlcy8ke3JhbmRvbVByb2ZpbGVGaWxlfWA7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgcmFuZG9tIHByb2ZpbGUgcGljdHVyZTpcIiwgZXJyb3IpO1xuICAgIC8vIFJldHVybiBhIGRlZmF1bHQgcHJvZmlsZSBwaWN0dXJlIHBhdGggaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIHJldHVybiBcIi9wcm9maWxlcy9kZWZhdWx0X3Byb2ZpbGUuanBlZ1wiO1xuICB9XG59XG5cbi8qKlxuICogU2VydmVyLXNpZGUgZnVuY3Rpb24gdG8gZ2V0IGFsbCBhdmFpbGFibGUgcHJvZmlsZSBwaWN0dXJlc1xuICogQHJldHVybnMgQXJyYXkgb2YgcGF0aHMgdG8gYWxsIHByb2ZpbGUgcGljdHVyZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFByb2ZpbGVQaWN0dXJlcygpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBQUk9GSUxFX1BJQ1RVUkVTLm1hcCgoZmlsZSkgPT4gYC9wcm9maWxlcy8ke2ZpbGV9YCk7XG59XG5cbi8qKlxuICogQ2xpZW50LXNpZGUgZnVuY3Rpb24gdG8gZ2V0IHNhdmVkIHByb2ZpbGUgcGljdHVyZSBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAqIEByZXR1cm5zIFRoZSBzYXZlZCBwcm9maWxlIHBpY3R1cmUgcGF0aCBvciBudWxsIGlmIG5vbmUgaXMgc2F2ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNhdmVkUHJvZmlsZVBpY3R1cmUoKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwicHJvZmlsZVBpY3R1cmVcIik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2xpZW50LXNpZGUgZnVuY3Rpb24gdG8gc2F2ZSBhIHByb2ZpbGUgcGljdHVyZSBwYXRoIHRvIGxvY2FsIHN0b3JhZ2VcbiAqIEBwYXJhbSBwcm9maWxlUGF0aCBUaGUgcHJvZmlsZSBwaWN0dXJlIHBhdGggdG8gc2F2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVByb2ZpbGVQaWN0dXJlKHByb2ZpbGVQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInByb2ZpbGVQaWN0dXJlXCIsIHByb2ZpbGVQYXRoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsaWVudC1zaWRlIGZ1bmN0aW9uIHRvIGdldCB0aGUgY3VycmVudCBwcm9maWxlIHBpY3R1cmUgb3IgZ2VuZXJhdGUgYSBuZXcgb25lIGlmIG5vbmUgZXhpc3RzXG4gKiBAcmV0dXJucyBUaGUgY3VycmVudCBwcm9maWxlIHBpY3R1cmUgcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFByb2ZpbGVQaWN0dXJlKCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3Qgc2F2ZWRQcm9maWxlUGljdHVyZSA9IGdldFNhdmVkUHJvZmlsZVBpY3R1cmUoKTtcbiAgICBpZiAoc2F2ZWRQcm9maWxlUGljdHVyZSkge1xuICAgICAgcmV0dXJuIHNhdmVkUHJvZmlsZVBpY3R1cmU7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgbmV3IG9uZSBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICAvLyBXZSBjYW4ndCB1c2UgZnMgb24gY2xpZW50IHNpZGUsIHNvIHdlJ2xsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHlcbiAgfVxuICByZXR1cm4gXCIvcHJvZmlsZXMvZGVmYXVsdF9wcm9maWxlLmpwZWdcIjtcbn1cblxuLyoqXG4gKiBDbGllbnQtc2lkZSBmdW5jdGlvbiB0byBmZXRjaCBhIHJhbmRvbSBwcm9maWxlIHBpY3R1cmUgZnJvbSB0aGUgQVBJXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSByYW5kb20gcHJvZmlsZSBwaWN0dXJlIHBhdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUmFuZG9tUHJvZmlsZVBpY3R1cmUoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9wcm9maWxlL3JhbmRvbVwiKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhLnByb2ZpbGVQaWN0dXJlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByYW5kb20gcHJvZmlsZSBwaWN0dXJlOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIFwiL3Byb2ZpbGVzL2RlZmF1bHRfcHJvZmlsZS5qcGVnXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGllbnQtc2lkZSBmdW5jdGlvbiB0byByZWZyZXNoIHRoZSBwcm9maWxlIHBpY3R1cmUgd2l0aCBhIG5ldyByYW5kb21seSBnZW5lcmF0ZWQgb25lXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBwcm9maWxlIHBpY3R1cmUgcGF0aFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFByb2ZpbGVQaWN0dXJlKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG5ld1Byb2ZpbGVQaWN0dXJlID0gYXdhaXQgZmV0Y2hSYW5kb21Qcm9maWxlUGljdHVyZSgpO1xuICBzYXZlUHJvZmlsZVBpY3R1cmUobmV3UHJvZmlsZVBpY3R1cmUpO1xuICByZXR1cm4gbmV3UHJvZmlsZVBpY3R1cmU7XG59XG4iXSwibmFtZXMiOlsiUFJPRklMRV9QSUNUVVJFUyIsImdldFJhbmRvbVByb2ZpbGVQaWN0dXJlIiwicmFuZG9tSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJyYW5kb21Qcm9maWxlRmlsZSIsImVycm9yIiwiY29uc29sZSIsImdldEFsbFByb2ZpbGVQaWN0dXJlcyIsIm1hcCIsImZpbGUiLCJnZXRTYXZlZFByb2ZpbGVQaWN0dXJlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNhdmVQcm9maWxlUGljdHVyZSIsInByb2ZpbGVQYXRoIiwic2V0SXRlbSIsImdldEN1cnJlbnRQcm9maWxlUGljdHVyZSIsInNhdmVkUHJvZmlsZVBpY3R1cmUiLCJmZXRjaFJhbmRvbVByb2ZpbGVQaWN0dXJlIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwicHJvZmlsZVBpY3R1cmUiLCJyZWZyZXNoUHJvZmlsZVBpY3R1cmUiLCJuZXdQcm9maWxlUGljdHVyZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/profilePictureSelector.ts\n"));

/***/ })

});